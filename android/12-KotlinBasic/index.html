<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Kotlin プログラミング基礎 | Android programing getstart</title><link rel="stylesheet" type="text/css" href="/AndroidCourse//css/normalize.css"><link rel="stylesheet" type="text/css" href="/AndroidCourse//css/highlight.css"><link rel="stylesheet" type="text/css" href="/AndroidCourse//css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="../../favicon.ico"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="../../." class="title">Android programing getstart</a><span class="subtitle"></span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="../../index.html" class="sidebar-nav-item">Home</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>Kotlin プログラミング基礎</h1></div></div>
<article><div class="container post"><p>Kotlinを使ったプログラミングとして基礎を学習します。</p>
<!-- toc -->
<ul>
<li><a href="#学習ポイント">学習ポイント</a></li>
<li><a href="#kotlin言語の特徴">Kotlin言語の特徴</a><ul>
<li><a href="#変数">変数</a></li>
<li><a href="#関数">関数</a></li>
<li><a href="#制御構文">制御構文</a><ul>
<li><a href="#if文">if文</a></li>
<li><a href="#when文">when文</a></li>
<li><a href="#for文">for文</a></li>
<li><a href="#while文">while文</a></li>
</ul>
</li>
<li><a href="#クラス">クラス</a><ul>
<li><a href="#クラス定義">クラス定義</a></li>
<li><a href="#継承-インターフェース">継承、インターフェース</a></li>
<li><a href="#静的メンバへのアクセス">静的メンバへのアクセス</a></li>
</ul>
</li>
<li><a href="#object">object</a><ul>
<li><a href="#無名オブジェクトの定義">無名オブジェクトの定義</a></li>
<li><a href="#シングルトンの定義">シングルトンの定義</a></li>
</ul>
</li>
<li><a href="#ラムダ式">ラムダ式</a></li>
<li><a href="#スコープ関数">スコープ関数</a><ul>
<li><a href="#let関数">let関数</a></li>
<li><a href="#with">with</a></li>
<li><a href="#run">run</a></li>
<li><a href="#apply">apply</a></li>
<li><a href="#also">also</a></li>
</ul>
</li>
<li><a href="#any-unit-nothing">Any, Unit, Nothing</a><ul>
<li><a href="#any">Any</a></li>
<li><a href="#unit">Unit</a></li>
<li><a href="#nothing">Nothing</a></li>
</ul>
</li>
<li><a href="#検査例外">検査例外</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1><span id="学習ポイント">学習ポイント</span></h1><ul>
<li>Kotlin言語の特徴</li>
<li>Kotlin - Javaの差分</li>
</ul>
<p>Google I/O 2017にて正式にAndroid開発言語として公式サポートとなった言語Kotlinについて学習します。</p>
<h1><span id="kotlin言語の特徴">Kotlin言語の特徴</span></h1><p>Javaをベースに開発された言語であるため、Javaと同じくJVM上で動作する言語、そのため様々なプラットフォームでの実行が可能。<br>開発元のJetBrains社もJavaと完全な相互運用可能を提言しています。</p>
<p>完全互換性言語ということでAndroidアプリの開発においてJavaで作成したプロジェクトに対して１ファイルだけKotlinという導入も可能である。<br>またJavaを使い慣れていれば抵抗感が少なくKotlinのプログラムが行えるような設計がなされています。<br>Kotlinはjava言語ではないのでないのでファイル拡張子も変わるのですが、<strong><em>[ファイル名].kt</em></strong>の形式でファイルが作成されます。<br>当ページでは以下の項目に関して解説をしていきます。</p>
<ul>
<li>変数</li>
<li>関数</li>
<li>制御構文の変更点</li>
<li>クラスの定義</li>
<li>Unit, Nothing, Any</li>
<li>object, companion object</li>
<li>スコープ関数</li>
<li>ラムダ式</li>
<li>try-catch</li>
</ul>
<p>Kotlinは公式サイトより導入せずとも試すことができます。<br><a href="https://try.kotlinlang.org/" target="_blank" rel="external">Kotlin Playground</a></p>
<h2><span id="変数">変数</span></h2><p>Kotlinは最近の言語で増えてきた推論型変数、オプショナル（Null-safety）などの概念が追加されています。</p>
<p>先ずは変数ですが宣言の方法が以下のキーワードを使います。</p>
<ul>
<li>var -&gt; 変更可能な変数</li>
<li>val -&gt; １度だけ代入できる変数(ローカル変数としての利用を想定)</li>
</ul>
<p><strong>推論型変数</strong><br>変数の宣言のみを記述する場合には明示的に型を指定する必要がありますが、<br>宣言と同時に代入を行う場合、代入されたデータの型として推論されそれ以降では代入したデータの方として扱われる変数となりす。<br>そのため他の型やクラス以外のデータは代入できなくなります。</p>
<p>また、Kotlinでは原則宣言時に初期化が必須なのですが、宣言時に値を入れない方法もあり、varキーワードの前に<code>lateinit</code>と記述することで宣言のみを記述できます。<br><figure class="highlight java"><figcaption><span>Java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//変数宣言のみ</span></span><br><span class="line">String hoge;</span><br><span class="line"><span class="comment">// 変数宣言と同時に初期化</span></span><br><span class="line">String fuga = <span class="string">"Android"</span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//変数宣言のみ</span></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> hoge: String</span><br><span class="line"><span class="comment">// 変数宣言と同時に初期化</span></span><br><span class="line"><span class="comment">// String型の変数として扱われる</span></span><br><span class="line"><span class="keyword">var</span> fuga = <span class="string">"Android"</span></span><br></pre></td></tr></table></figure>
<p>そして変数の宣言時には合わせてそれ以降のプログラムで宣言した変数にNullの代入可否を設定する必要があり、その設定を<strong><em>Null-Safety(オプショナル)</em></strong>と呼びます<br><figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Nullを許容しない変数</span></span><br><span class="line"><span class="keyword">var</span> hoge = <span class="string">"hogehoge"</span></span><br><span class="line">hoge = <span class="literal">null</span>			<span class="comment">// コンパイルエラー</span></span><br><span class="line"><span class="comment">// Nullを許容する変数</span></span><br><span class="line"><span class="keyword">var</span> fuga: String? = <span class="string">"fugafuga"</span></span><br><span class="line">fuga = <span class="literal">null</span>			<span class="comment">// 代入可</span></span><br></pre></td></tr></table></figure></p>
<p>オプショナルを設定することで実行時エラー（NullPointerException）などの発生をエラーを予測して実装と動作確認することができます。<br>さらにNull許容型の変数を作成した場合でもNullのチェックは簡潔に行えるよう機能が追加されており、その機能が<code>let</code>関数になります。<br><figure class="highlight java"><figcaption><span>Java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String hoge = fuga != <span class="keyword">null</span> ? fuga : <span class="string">"hogehoge"</span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> hoge = fuga?.let &#123; fuga &#125; ?: <span class="keyword">else</span> &#123; <span class="string">"hogehoge"</span> &#125;</span><br></pre></td></tr></table></figure>
<p>上記Kotlinの例では<code>fuga</code>がnullではない場合はfugaを代入、nullの場合は”hogehoge”をhogeに代入する式担っています。<br><code>let</code>単体の式の場合で変数の結果がnullの場合にはnullが代入される仕様になっています。<br><code>let</code>に関してはスコープ関数の項目で細かい話に触れていきます。</p>
<p>また、Kotlinではキャストの方法も変更されて変更されており、キャストには<code>as</code>キーワードを使用します。<br><figure class="highlight java"><figcaption><span>Java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> numLong = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// Long型をInt型にキャスト</span></span><br><span class="line"><span class="keyword">int</span> num = (<span class="keyword">int</span>) numLong;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numLong: <span class="built_in">Long</span> = <span class="number">10</span></span><br><span class="line"><span class="comment">// Long型をInt型にキャスト</span></span><br><span class="line"><span class="keyword">var</span> num: <span class="built_in">Int</span> = num <span class="keyword">as</span> <span class="built_in">Int</span></span><br></pre></td></tr></table></figure>
<h2><span id="関数">関数</span></h2><p>関数の定義方法に変更が加わりましたが、参照方法に変更はありません。</p>
<p>以下はInt型引数が１つで戻り値型がInt型のメソッドの定義方法になります。<br><figure class="highlight java"><figcaption><span>Java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// メソッドの定義</span></span><br><span class="line"><span class="comment">// [アクセス修飾子] [戻り値型] [メソッド名]([引数型] [引数名], [引数型] [引数名]...) &#123;</span></span><br><span class="line"><span class="comment">//     メソッドの処理</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	   <span class="keyword">return</span> x + <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// メソッドの参照</span></span><br><span class="line">	calc(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// メソッドの定義</span></span><br><span class="line"><span class="comment">// [アクセス修飾子] fun [メソッド名]([引数名]: [引数型], [引数名]: [引数型]): [戻り値型]...) &#123;</span></span><br><span class="line"><span class="comment">//     メソッドの処理</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">calc</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x + <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// メソッドの参照</span></span><br><span class="line">	calc(<span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="制御構文">制御構文</span></h2><p>Kotlinでもif文、for文、while、do-whileなどはある程度javaと同じように利用できると思います。<br>Kotlinではswitchの代わりになるもので<strong>when</strong>という制御構文が追加されています。<br>また、Kotlinには三項演算子(条件演算子)はなくなり、if文を短縮して記述することですることで三項演算子の様に利用することができます。</p>
<h3><span id="if文">if文</span></h3><p>java言語と基本的な利用方法は同じです、Kotlinでの特殊な利用方法として代入式としてif文を利用することができます。</p>
<p>代入式としてif文を利用する場合は最後に記述した変数や式が右辺の変数に代入されます。<br>Kotlinではif文が代入式として使用できるので三項演算子(条件演算子)は使えなくなっています。<br><figure class="highlight java"><figcaption><span>Java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常のif文の記述方法</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">1</span> &amp;&amp; a &lt; <span class="number">31</span>) &#123;</span><br><span class="line">    <span class="comment">// 実行したい処理を記述</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if文を利用した変数への代入</span></span><br><span class="line"><span class="keyword">int</span> num  = a &lt; i ? <span class="number">0</span> : <span class="number">10</span> ;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常のif文の記述方法</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">1</span> &amp;&amp; a &lt; <span class="number">31</span>) &#123;</span><br><span class="line">    <span class="comment">// 実行したい処理を記述</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if文を利用した変数への代入</span></span><br><span class="line"><span class="keyword">var</span> num: <span class="built_in">Int</span> = <span class="keyword">if</span>(a &lt; i) &#123; <span class="number">0</span> &#125; <span class="keyword">else</span> &#123; <span class="number">10</span> &#125;</span><br></pre></td></tr></table></figure>
<h3><span id="when文">when文</span></h3><p>Javaや他の言語であるswitchの置き換え構文になります。<br>case文の代わりには<code>-&gt;（アロー演算子）</code>を使用します、各条件の時に１行で済むコードであればアロー演算子の後に半角スペースを挟んで記述できます。<br>複数行であればアロー演算子の後に<code>{}</code>をつけてブロック内にコードを記述します。<br>さらに複数の条件を指定したい場合は、条件を<code>,（カンマ）</code>で区切り条件を設定します。<br><figure class="highlight java"><figcaption><span>Java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(num) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">	    <span class="comment">// numが0の場合の処理</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	    <span class="comment">// numが1の場合の処理</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">	    <span class="comment">// numが2,3の場合の処理		</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	    <span class="comment">// 全てのcase条件に該当しなかった場合の処理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span>(num) &#123;</span><br><span class="line">	<span class="number">0</span> -&gt;    <span class="comment">// numが0の場合の処理</span></span><br><span class="line">	<span class="number">1</span> -&gt; &#123;</span><br><span class="line">	    <span class="comment">// numが1の場合の処理</span></span><br><span class="line">	    <span class="comment">// 処理が複数行の場合は&#123;&#125; ブロックをブロックを記述</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="number">2</span>,<span class="number">3</span> -&gt;  <span class="comment">// numが2,3の場合の処理</span></span><br><span class="line">	<span class="keyword">else</span> -&gt; <span class="comment">// 上記全ての条件に該当しなかった場合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>when構文では分岐条件の設定に<code>in</code>で条件範囲を設けたり<code>is</code>で型のチェックを条件に設定することも可能です。<br><code>!in</code>や<code>!is</code>と使うことで範囲外、型ではないなどの判定条件としても設定できます。<br><figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span>(num) &#123;</span><br><span class="line">	<span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> -&gt;    <span class="comment">// numが1~10の範囲内だった時の処理</span></span><br><span class="line">	<span class="keyword">is</span> <span class="built_in">Int</span> -&gt;      <span class="comment">// numがInt型だった場合の処理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>when構文もif文と同様に代入式として使用することも可能です、さらにwhen構文に引数を与えなかった場合、if-else文代替えとして認識され分岐条件の設定は論理型の判定になります。<br><figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hogeにwhen文で判定した結果が代入される</span></span><br><span class="line"><span class="keyword">val</span> hoge = <span class="keyword">when</span> &#123;</span><br><span class="line">	<span class="comment">// 条件設定はtrue/falseの結果になるよう記述が必要</span></span><br><span class="line">	fuga == <span class="number">0</span> -&gt; <span class="number">10</span></span><br><span class="line">	fuga == <span class="number">10</span> -&gt; <span class="number">20</span></span><br><span class="line">	<span class="keyword">else</span> -&gt; <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3><span id="for文">for文</span></h3><p>Kotlinでのfor文はJavaに置ける拡張for(foreach)文の形式でしか使用することができません。<br>拡張for文形式で指定回数の繰り返しを行う例も合わせ紹介します。<br><figure class="highlight java"><figcaption><span>Java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0~10を2ずつ加算するfor文</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i+=<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 繰り返し時の処理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拡張for文</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> num: numbers) &#123;</span><br><span class="line">    <span class="comment">// 繰り返し時の処理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0~10を2ずつ加算するfor文</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> step <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 繰り返し時の処理		</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// イテレータによるfor文</span></span><br><span class="line"><span class="keyword">for</span>(num : numbers) &#123;</span><br><span class="line">    <span class="comment">// 繰り返し時の処理		</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>また<code>downTo</code>キーワードを使うことで降順的にfor文を処理することも可能です。<br><figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20 ~ 0までの範囲でfor文を実行</span></span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">20</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">// 繰り返し時の処理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 20 ~ 0までの範囲で2ずつ下げるfor文を実行</span></span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">20</span> downTo <span class="number">0</span> step <span class="number">2</span>) &#123;</span><br><span class="line">	<span class="comment">// 繰り返し時の処理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>もしインデックス付きのfor文を処理したい場合は<code>indices</code>メンバや<code>withIndex()</code>メソッドを使用するとインデックスを使いながらfor文を実行することもできます。<br><figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// インデックスを使ったfor文</span></span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> array.indices) &#123;</span><br><span class="line">    println(array[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// インデックスと値を使ったfor文</span></span><br><span class="line"><span class="keyword">for</span>((index, value) <span class="keyword">in</span> array.withIndex()) &#123;</span><br><span class="line">    println(<span class="string">"インデックス：<span class="subst">$&#123;index&#125;</span>, \t値：<span class="subst">$&#123;value&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3><span id="while文">while文</span></h3><p>while, do-while文に関してはJavaや他の言語と同様の記述ルールになります。</p>
<h2><span id="クラス">クラス</span></h2><p>クラスに関してもJavaから一部変更が入っていますが、概ね同じルールで記述していきます。<br>class定義の際にpublic修飾は不要となり、コンストラクタの記述方法が変更されました。</p>
<h3><span id="クラス定義">クラス定義</span></h3><p>以下で紹介するのは引数が２つあり、コンストラクタが一つ（プライマリコンストラクタ）の実装例になります。<br>コンストラクタに引数がない場合はJava同様記述する必要はなく、デフォルトコンストラクタが有効になります。<br><figure class="highlight java"><figcaption><span>Java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引数が２つありメンバを初期化しているクラス</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hoge</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	String str;</span><br><span class="line">	hoge(<span class="keyword">int</span> num, String str) &#123;</span><br><span class="line">		<span class="keyword">this</span>.num = num;</span><br><span class="line">		<span class="keyword">this</span>.str = str;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// デフォルトコンストラクタを有効にしているクラス</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fuga</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引数が２つありメンバを初期化しているクラス</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hoge</span></span>(num: <span class="built_in">Int</span>, str: String) &#123;</span><br><span class="line">	<span class="keyword">var</span> num = num</span><br><span class="line">	<span class="keyword">var</span> str = str</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// デフォルトコンストラクタを有効にしているクラス</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fuga</span> </span>&#123;</span><br><span class="line">	int num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>プライマリコンストラクタに初期化時の処理をつける場合は以下の通り実装する<br><figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hoge</span></span>(num: <span class="built_in">Int</span>, str: String) &#123;</span><br><span class="line">	<span class="keyword">var</span> num = num</span><br><span class="line">	<span class="keyword">var</span> str = str</span><br><span class="line">	init &#123;</span><br><span class="line">		<span class="comment">// プライマリコンストラクタの</span></span><br><span class="line">		<span class="comment">// 初期化処理</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>セカンダリコンストラクタを定義する場合は<code>constructor</code>キーワードを使用して定義します。<br><figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hoge</span></span>(num: <span class="built_in">Int</span>, str: String) &#123;</span><br><span class="line">	<span class="keyword">var</span> num = num</span><br><span class="line">	<span class="keyword">var</span> str = str</span><br><span class="line">	<span class="comment">// セカンダリコンストラクタの定義</span></span><br><span class="line">	<span class="comment">// プライマリコンストラクタへ移譲する定義が必要</span></span><br><span class="line">	<span class="keyword">constructor</span>(num: <span class="built_in">Int</span>): <span class="keyword">this</span>(num, <span class="string">"hoge"</span>) &#123;</span><br><span class="line">		<span class="comment">// セカンダリコンストラクタの初期化処理</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>インスタンスの作成はJavaと違い<em>new</em>キーワードなしでコンストラクタを呼び出します。<br><figure class="highlight java"><figcaption><span>Java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hoge inc = <span class="keyword">new</span> hoge(<span class="number">0</span>, <span class="string">"str"</span>);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> inc = hoge(<span class="number">0</span>, <span class="string">"str"</span>);</span><br></pre></td></tr></table></figure>
<h3><span id="継承-インターフェース">継承、インターフェース</span></h3><p>継承や、インターフェースの実装に使用していた、<strong>extends</strong>や<strong>implements</strong>キーワードもなくなり,<br>プライマリコンストラクタの後ろに<code>: [親Class名]([親Classプライマリコンストラクタの実引数])</code>の形式で継承関係を記述し、<br><code>,（カンマ）</code>区切りで実装するインターフェースを記述します。<br>Kotlinでは継承関係を記述しなかった場合、暗黙的に<code>Any</code>クラスの子クラスとなります。<br><code>Any</code>クラスと<code>java.util.Object</code>とは別のクラスになりますので注意してください。<br>またKotlinでは継承元となる親クラスの定義に<code>open</code>キーワードの修飾が必要になるので注意してください。<br>メソッドを<code>orverride</code>させるにはメソッドの定義にも先頭に<code>open</code>を記述してください。<br><figure class="highlight java"><figcaption><span>Java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SuperHogeクラスを継承し、Fugaインターフェースを実装するHogeクラスの定義</span></span><br><span class="line"><span class="comment">// SuperHogeクラスのプライマリコンストラクタは引数なしです。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hoge</span> <span class="keyword">extends</span> <span class="title">SuperHoge</span> <span class="title">inmplements</span> <span class="title">Fuga</span> </span>&#123;</span><br><span class="line">	<span class="comment">// SuperHogeクラスのfooメソッドをオーバーライド</span></span><br><span class="line">	<span class="meta">@orverride</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 継承元の親クラスを定義</span></span><br><span class="line"><span class="keyword">public</span> classSuperHoge&#123;</span><br><span class="line">	<span class="comment">// orvrerideできるメソッドの定義</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SuperHogeクラスを継承し、Fugaインターフェースを実装するHogeクラスの定義</span></span><br><span class="line"><span class="comment">// SuperHogeクラスのプライマリコンストラクタは引数なしです。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hoge</span>: <span class="type">SupreHoge</span></span>(), Fuga &#123;</span><br><span class="line">	<span class="comment">// SuperHogeクラスのfooメソッドをオーバーライド</span></span><br><span class="line">	orverride <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 継承元の親クラスを定義</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperHoge</span></span>() &#123;</span><br><span class="line">	<span class="comment">// orvrerideできるメソッドの定義</span></span><br><span class="line">	<span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>抽象クラス</strong>に関してはJava同様<code>abstract</code>キーワードを使い抽象クラスとして定義することができます、また抽象クラスは<code>open</code>キーワードを付与しなくてもオーバーライドすることは可能です。</p>
<h3><span id="静的メンバへのアクセス">静的メンバへのアクセス</span></h3><p>KotlinはJavaと違い<strong>static</strong>な変数や定数、メソッドを定義することができません。<br>その場合の方法としてKotlinではクラスブロック外に変数、定数、メソッドを定義することができるので<strong>static</strong>メソッドの代わりに使用することができます。<br>また、クラスブロック内に<code>companion object</code>（コンパニオンオブジェクト）キーワードを使ったブロックを作りブロック内に変数、定数、メソッドを定義する方法もあります。<br>前者の場合はクラス名の修飾なしに各定義を参照することができます、後者はクラス名の修飾を使って各定義を参照できます。</p>
<p>クラス外に定義された内容はプロジェクト単位でユニークな扱いを受けるので、他のクラスで同名の定義を行うとコンパイルエラーが発生します。<br>そのため、Fragmentなどのように静的コンストラクタを定義したい場合などは<code>companion object</code>に定義をし、クラス外には画面遷移時のパラメータキーやプロジェクト内でユニークな定数に分けるなどすると使い易くなります。<br><figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sample</span><br><span class="line"><span class="comment">// クラス外の定数定義</span></span><br><span class="line">const <span class="keyword">val</span> FOO = <span class="number">10</span></span><br><span class="line"><span class="comment">// クラス外のメソッド定義</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bar</span> <span class="params">(a: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hoge</span> </span>&#123;</span><br><span class="line">	<span class="comment">// コンパニオンオブジェクトを使ったメソッドの定義</span></span><br><span class="line">	<span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">		<span class="function"><span class="keyword">fun</span> <span class="title">fuga</span> <span class="params">(b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>  &#123;</span><br><span class="line">			<span class="keyword">return</span> b *<span class="number">3</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hogeクラス(Hoge.kt)の要素を参照するクラス</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hogehoge</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">runMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// Hoge.ktのbarメソッドを参照</span></span><br><span class="line">		<span class="keyword">val</span> res1 = bar(FOO)</span><br><span class="line">		<span class="comment">// Hoge.ktのfugaメソッドを参照</span></span><br><span class="line">		<span class="keyword">val</span> res2 = Hoge.fuga(FOO)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>const</code>キーワードを付けて記述した場合はJavaにおいて<strong>static</strong>な要素として扱われるのに対し、<code>const</code>なしで記述した物はJavaに変換された時にアクセサメソッドが定義されてしまうので、できるだけ<code>const</code>を付けて記述した方が良いです。</p>
<h2><span id="object">object</span></h2><p><code>object</code>にはいつかの用途があり、一つが<strong>クラス</strong>内で紹介した<code>companion object</code>です。<br>その他では以下の使い方で使用されることがあります、それぞれの使用方法について紹介していきます。</p>
<ul>
<li>無名オブジェクトの定義</li>
<li>シングルトンの定義</li>
</ul>
<h3><span id="無名オブジェクトの定義">無名オブジェクトの定義</span></h3><p>Android Javaにおいてはボタンなどのクリックイベントなど、引数にインスタンス化したオブジェクトを返す箇所などが無名クラスでの置き換えになります。</p>
<p>以下例は画面のボタンコンポーネントに無名オブジェクトを使いクリックイベントをセットしています。<br><figure class="highlight java"><figcaption><span>Java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HogeActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.hogehoge);</span><br><span class="line">        Button btn = findViewById(R.id.button);</span><br><span class="line">        <span class="comment">// インターフェースをオブジェクト化してクリックイベントをセット</span></span><br><span class="line">        btn.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123; ... &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HogeActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> btn = findViewById(R.id.button)</span><br><span class="line">        <span class="comment">// 無名オブジェクトを使ってクリックイベントをセット</span></span><br><span class="line">        btn.setOnClickListener(<span class="keyword">object</span> : View.OnClickListener &#123; ... &#125;) </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3><span id="シングルトンの定義">シングルトンの定義</span></h3><p>APIやデータベースなど都度インスタンス化して使うのが手間になるクラスも存在します、その場合にプロジェクト内でクラスのインスタンスが一つしか生成されない様に設計されたクラスをシングルトンと呼びます。<br>Javaでのシングルトンの使い方はメソッドからメソッドへ繋ぐメソッドチェーンで使用するのが一般的でしたが<br>Kotlinでは<code>objectの宣言</code>によってJavaのクラスメソッドのようにシングルトンを使用できるようになりました。</p>
<p>以下の例はシングルトンクラス’Hoge’を作成し、Fugaクラスにて利用している例になります。<br><figure class="highlight java"><figcaption><span>Java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// シングルトンクラスHogeの定義</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hoge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Hoge instance = <span class="keyword">new</span> Hoge();</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Hoge</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hoge <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    		instance = <span class="keyword">new</span> Hoge();</span><br><span class="line">    	&#125; </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calcPlus10</span><span class="params">(<span class="keyword">double</span> dec)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> dec + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Hogeクラスを使用するFugaクラス</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fuga</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Fuga</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="comment">// シングルトンHogeクラスを参照</span></span><br><span class="line">	    a = Hoge.getInstance().calcPlus10(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// シングルトンクラスHogeの定義</span></span><br><span class="line"><span class="keyword">object</span> Hoge &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">calcPlus10</span><span class="params">(dec: <span class="type">Double</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> dec + <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Hogeクラスを使用するFugaクラス</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fuga</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a: int = <span class="number">0</span>;</span><br><span class="line">	init &#123;</span><br><span class="line">	    <span class="comment">// シングルトンHogeクラスを参照</span></span><br><span class="line">	    a = Hoge.calcPlus10(<span class="number">10</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="ラムダ式">ラムダ式</span></h2><p>ラムダ式は<strong>メソッドの定義を式として扱い、即時実行された結果を機能</strong>を指します。<br>関数型リテラルとも呼ばれることがあり、関数が宣言されたのではなく式として宣言した変数に代入された形となります。<br>実際に使用してみると、<em>‘変数名(引数)’</em>の形式で参照するため、見栄えとして後から関数を作成したように感じます。</p>
<p>以下の例は二つの値の和を求めるラムダ式になります。<br><figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 無名関数の定義</span></span><br><span class="line"><span class="keyword">val</span> sum = &#123;x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y&#125;</span><br><span class="line"><span class="comment">// 無名関数の使用例</span></span><br><span class="line"><span class="keyword">val</span> total = sum(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>
<p>またラムダ式を使うことでリストなどのコレクション型のデータから特定の条件に該当するデータだけを抽出する時によく利用します。<br>ラムダ式を使う場合に引数の値が１つの場合、暗黙的に一時変数名<code>it</code>として設定されていることに注意してください。</p>
<p>以下ではコレクションとの組み合わせによる例を紹介します。<br><figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tmpList: listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">// コレクションのメソッドに対してラムダを適用した例</span></span><br><span class="line">tmpList.count &#123;it % <span class="number">2</span> ==<span class="number">1</span>&#125; <span class="comment">// List型で奇数の1,3が含まれたオブジェクトを取得できる</span></span><br><span class="line">tmpList.filter &#123;it == <span class="number">2</span>&#125; <span class="comment">// List型で2が含まれたオブジェクトを取得できる</span></span><br></pre></td></tr></table></figure></p>
<h2><span id="スコープ関数">スコープ関数</span></h2><p>Kotlin標準ライブラリに含まれている機能。<br>対象オブジェクトやスコープ関数に渡した引数に限定して即時関数を実行する機能。<br>利用できる種類としては現状(2018/05/19時点でkotlin 1.2.41が最新)では以下５つが有効なスコープ関数として登録されています。</p>
<table>
<thead>
<tr>
<th style="text-align:center">関数 \ 項目</th>
<th style="text-align:left">操作オブジェクト</th>
<th style="text-align:left">戻り値</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">let</td>
<td style="text-align:left">it</td>
<td style="text-align:left">指定可</td>
</tr>
<tr>
<td style="text-align:center">with</td>
<td style="text-align:left">this</td>
<td style="text-align:left">指定可</td>
</tr>
<tr>
<td style="text-align:center">run</td>
<td style="text-align:left">this</td>
<td style="text-align:left">指定可</td>
</tr>
<tr>
<td style="text-align:center">apply</td>
<td style="text-align:left">this</td>
<td style="text-align:left">操作オブジェクト</td>
</tr>
<tr>
<td style="text-align:center">also</td>
<td style="text-align:left">it</td>
<td style="text-align:left">操作オブジェクト</td>
</tr>
</tbody>
</table>
<p>また、スコープ関数の中でも<code>let</code>,<code>apply</code>はAndroid開発の中での利用頻度は高くなる印象があります。<br><code>let</code>はオプショナルのunwrappeで使用しますし、<code>apply</code>に関しては複数の項目を設定した場合などに使用できるのでFragmentの静的コンストラクタや<br>HashMapによる複数項目の設定などを一括で行うような記述が行えるメリットがあります。</p>
<blockquote>
<p><a href="http://nyanyoni.hateblo.jp/entry/2017/08/19/152200" target="_blank" rel="external">Kotlinのスコープ関数を使い分けたい</a>を参照</p>
</blockquote>
<h3><span id="let関数">let関数</span></h3><p><code>let</code>関数の定義がこちら↓<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>)</span></span> -&gt; R): R = block(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure></p>
<p>自身を引数としてラムダ式を実行する機能を持っている、ラムダブロック最後に記述されているオブジェクト（変数）を戻り値として返却する。<br>また、<strong>Null許容変数のUnwappe(Nullチェック)によく使用される</strong><br><code>let</code>の実装サンプルは以下<br><figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [Object].let &#123; [処理] &#125;</span></span><br><span class="line"><span class="comment">// 実際の使い方</span></span><br><span class="line"><span class="keyword">val</span> fuga = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> hoge = fuga.let &#123; it + <span class="number">10</span> &#125; <span class="comment">// hoge: 30</span></span><br></pre></td></tr></table></figure></p>
<p>上記のコードでい変数”fugaが + 10”を”hoge”に代入する式となりました、ではNullチェックでの使用方法を紹介します。<br><figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// オプショナルの設定された変数のUnwrappeを行う</span></span><br><span class="line"><span class="keyword">val</span> hoge = fuga?.let &#123; [fugaが<span class="literal">null</span>じゃない時の処理] &#125; ?: &#123; [fugaが<span class="literal">null</span>の場合の処理] &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>let</code>に関してはNullのUnwrappeでの利用が大いのでまずは上記２つの内、後者を特に覚えておけば良いと思います。</p>
<h3><span id="with">with</span></h3><p><code>with</code>関数の定義はこちら↓<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, f: <span class="type">T</span>.()</span></span> -&gt; R): R = receiver.f()</span><br></pre></td></tr></table></figure></p>
<p><code>with</code>はオブジェクトを修飾して呼び出す関数ではなく、通常の関数として用意されています。<br><code>with</code>関数は引数で指定されたオブジェクトをラムダ式で使用でき引数オブジェクトのメソッド等も参照することができます。<br>処理の最後に記述されているオブジェクト(変数)が戻り値になります<br>この後に出てくる<em>apply</em>とにているが戻り値になる値が違う点に注意してください。<br><figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// with([Object]) &#123; [処理] &#125;</span></span><br><span class="line"><span class="keyword">val</span> fuga = fuga(<span class="number">123</span>, <span class="string">"田中"</span>)</span><br><span class="line"><span class="keyword">val</span> hoge = with(fuga) &#123;</span><br><span class="line">	println(<span class="string">"id: <span class="subst">$&#123;getID()&#125;</span>"</span>)</span><br><span class="line">	getName()</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">"hoge: <span class="subst">$&#123;hoge&#125;</span>"</span>) <span class="comment">// hoge: 田中</span></span><br></pre></td></tr></table></figure></p>
<h3><span id="run">run</span></h3><p><code>run</code>関数の定義はこちら↓<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.()</span></span> -&gt; R): R = block()</span><br></pre></td></tr></table></figure></p>
<p><em>let</em>や<em>with</em>と同じように最後に記述されている式や値が戻り値として返却される<br>参照方法が<em>let</em>、ブロック内のオブジェクト呼び出しが<em>with</em>のように実装でき、<em>let</em>と<em>with</em>が合わさったような関数<br><figure class="highlight kotlin"><figcaption><span>Kotlin</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [Object].run &#123; [処理] &#125;</span></span><br><span class="line"><span class="keyword">val</span> fuga = fuga(<span class="number">123</span>, <span class="string">"田中"</span>)</span><br><span class="line"><span class="keyword">val</span> hoge = fuga.run &#123;</span><br><span class="line">	println(<span class="string">"id: <span class="subst">$&#123;getID()&#125;</span>"</span>)</span><br><span class="line">	getName()</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">"hoge: <span class="subst">$&#123;hoge&#125;</span>"</span>) <span class="comment">// hoge: 田中</span></span><br></pre></td></tr></table></figure></p>
<h3><span id="apply">apply</span></h3><p><code>apply</code>関数の定義はこちら↓<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.()</span></span> -&gt; <span class="built_in">Unit</span>): T &#123; block(); <span class="keyword">return</span> <span class="keyword">this</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>戻り値が<code>apply</code>関数を修飾したオブジェクトで固定されている、記述の方法などは<em>with</em>と同じ形で使用できる。<br>Android開発に置けるFragmentの処理が一部簡潔に記述できたりする<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// [Object].apply &#123; [処理] &#125;</span><br><span class="line">val fuga: Fuga = fuga(123, &quot;田中&quot;)</span><br><span class="line">// 戻り値はFugaクラスのインスタンス</span><br><span class="line">val hoge = fuga.apply &#123;</span><br><span class="line">	println(&quot;id: $&#123;getID()&#125;&quot;)</span><br><span class="line">	setName(&quot;山田&quot;)</span><br><span class="line">&#125;</span><br><span class="line">println(&quot;hoge: $&#123;hoge.getName&#125;&quot;) // hoge: 山田</span><br></pre></td></tr></table></figure></p>
<h3><span id="also">also</span></h3><p><code>also</code>関数の定義はこちら↓<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">also</span><span class="params">(block: (<span class="type">T</span>)</span></span> -&gt; <span class="built_in">Unit</span>): T &#123; block(<span class="keyword">this</span>); <span class="keyword">return</span> <span class="keyword">this</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>Kotlin Version:1.1から追加されたスコープ関数、使い方としては<em>apply</em>とほぼ同等だが、ラムダ式で修飾したオブジェクトに<br>仮引数名が設定でき、ラムダ式内外でthisのスコープが変わらないという特徴がある。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// [Object].apply &#123; [処理] &#125;</span><br><span class="line">val fuga: Fuga = fuga(123, &quot;田中&quot;)</span><br><span class="line">// 戻り値はFugaクラスのインスタンス</span><br><span class="line">val hoge = fuga.apply &#123; f -&gt;</span><br><span class="line">	println(&quot;id: $&#123;f.getID()&#125;&quot;)</span><br><span class="line">	f.setName(&quot;山田&quot;)</span><br><span class="line">	startActivity(Intent(this, NextActivity::class.java))</span><br><span class="line">&#125;</span><br><span class="line">println(&quot;hoge: $&#123;hoge.getName&#125;&quot;) // hoge: 山田</span><br></pre></td></tr></table></figure></p>
<h2><span id="any-unit-nothing">Any, Unit, Nothing</span></h2><p>Javaには存在しなかったキーワードが出てきたのでいくつか紹介します。</p>
<h3><span id="any">Any</span></h3><p>JavaではルートクラスがObjectクラスでしたが、KotlinではルートクラスがObjectではなく<code>Any</code>になります、KotlinにおいてもJavaのObjectクラスは存在しますが、Anyのサブ(子)クラスとして存在します。<br>Kotlinにはプリミティブ型は存在せず、全てがクラスとして扱われるようになります。<br>そのため、Javaでのプリミティブ型をBoxing(ボクシング)する必要がなく、コンパイラが自動的にプリミティブ型に最適化されるよう設計されています。</p>
<h3><span id="unit">Unit</span></h3><p>またJavaでメソッドなど戻り値がない場合に使うキーワードとして<strong>void</strong>がありますが<code>Unit</code>という<strong>void</strong>と同じく意味のない値を返すことを示すキーワードが追加されています、<br>Kotlinでのメソッドの戻り値がない場合は何も型の指定を行いませんが、暗黙的に<code>Unit</code>が戻り値として設定される仕様になっています。</p>
<h3><span id="nothing">Nothing</span></h3><p><code>Nothing</code>は値が返されないことを示すキーワードになっており、メソッドの引数として設定すると、必ずExceptionをthrowするメソッドになります。<br>場面としてはあまり使われない記号になります。</p>
<h2><span id="検査例外">検査例外</span></h2><p>KotlinにはJavaと違い検査例外がないため、Javaの場合にコンパイルエラーが発生する箇所でもKotlinではコンパイルエラーが発生しません。<br>そのため、Kotlinではtry-catch文を一度も書かずとも実装を完結することができます。<br>ただコンパイル的な問題がないだけでプロジェクトとしての問題は別になるので、必要な箇所にはtry-catch文を記述するようにした方が良いでしょう。</p>
<p>以上で、Kotlin言語の使い方であったり、Java言語の比較の内容を紹介してきました。<br>このページの情報があればJava→Kotlinへの移行を行うときの不具合などの対応はできると思われます。</p>
</div><!-- comment system--><div class="container"><hr></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer">© 2018 <a href="/" rel="nofollow">kuririnz</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-63175607-3');ga('send','pageview');</script></html>